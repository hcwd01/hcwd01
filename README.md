생각

HW 개발할때는 SW의 의존성을 최소화하고 SW개발할 떄는 HW의존성을 최소화해야함

어떻게

임베디드 시스템을 구상하고 요구사항을 수집하고 대략적인 설계와 유스케이스를 만들면서 HW요구사항과 SW요구사항이 별개로 수집됨

이때 서로가 서로에게 의존성을 가지게 되지만 HW와 SW사이의 기능 동작을 추상화하면서 서로에게 요구사항을 추가하는것으로 개별적으로 진행할 수 있음

HW요구사항과 SW요구사항이 분리되고 설계하면서 SW는 물리적인 구조를 고려하지 않을수 있고 HW는 SW의 논리적인 구조를 신경쓸필요 없음

하지만 설계와 구현까지 진행되면서 칩종류, 추가 IC같은 세부사항 변경등 요구사항 변경이 발생될 수 있기 때문에 서로 충분한 여유과

급격한 코스트 상승이 발생하는 정보를 공유할 필요가 있음

HW 설계에서 임베디드 시스템이 제공해야하는 기능들을 제공해주기위한 HW장치들과 인터페이스를 제공하고 MCU나 IC를 특정해서 정하지 않게 설계하면서 SW의 설계 제약을 최소화하고

SW 설계에서 임데디드 시스템이 제공해야하는 기능의 로직과 HW장치 제어를 제공하고 마찬가지로 MCU나 IC를 특정하지 않게 설계해서 HW의 설계 제약을 최소화해야함

개별적으로 개발 결과물, 통합한 뒤 결과물, 지속적으로 변경된 SW와 HW 반영물들을 서로 전달하면서 자연스럽게 서로 다른 SW버전, 서로 다른 HW 보드에 대한 크로스 플랫폼을 요구하게됨

이전 개발버전을 폐기한다면 없을 수 있지만 그러면 프로젝트 진행하면서한 오판을 번복하거나 개발하면서 발생한 오류를 수정하는데 비용이 커지고 프로젝트 크기에 제약이 생김

각각 크로스 플랫폼을 구현할수 있으면 결국 HW와 SW개발과정이 분리되고 병행적으로 개발이 가능함

문제점은 SW개발할 때나 HW개발할 떄 별도의 보드나 SW개발 수요가 발생함

따라서 분야별로 구분된 개발조직에 특화되지 않은 개발능력을 요구하게 되거나 서로에게 간접적인 개발요구를 하게됨

어떤게 더 나은지, 얼마나 나을지 모르겠지만 SW자산과 HW자산을 별개로 관리하게되면서 발생하는 리스크 관리와 병렬개발등 이점을 생각하면 이게 

=====

EEPROM 공부하면서 GCC 컴파일러의 링커 기능으로 초기화된 데이터를 제공하므로서 초기화 동작을 제거해서 코드를 축소할 수 있음

=====

SolarPowerManager를 진행하면서 전원의 효율성을 위해서 리니어 레귤레이터를 사용하다가 스위칭 레귤레이터를 사용하게 설계함

이것은 SW에 특정한 제어흐름과 기능을 요구하고 추가적인 핀을 요구함

=====

ADC라는 추상화 클래스를 만들고 AVR구현 코드에서 AVRADC라는 클래스를 구현하고 싶었지만 상속과정중 사용되는 ADC라는 식별자가 전처리기에 의해서 변경됨

전처리기 때문에 추상화코드를 구현하는 파일에서 추상화 코드의 이름을 제대로 참조하지 못하는 경우가 있음

=====

참조자는 매우 유용한거같은데 전역적으로 사용하기 어려움

참조자는 선언과 동시에 초기화되어야하는데 동적으로 조건에 따라 다른 객체를 참조하게 만들기위해서는 삼항연산자를 사용해야함

클래스에 참조자 변수를 넣어서 동적으로 설정하는것도 해봤지만 그렇게되면 링크단계에서 undefined reference to 'foo' 이런식으로 에러가 발생함

=====

아두이노 오버샘플링

여러번 읽고 평균을 구해서 좀더 높은 해상도의 값을 획득함

원리는 노이즈가 있는 입력을 원래의 분해능으로 구한 값사이의 평균으로 구하는것으로 노이즈가 너무 작으면 작동하지 않고 샘플링시간도 제곱으로 정확도역시 보장할 수 없음

예시 : ADC 5v에서 10비트 분해능(1024)로 1V를 측정할 때 1024의 1/5값인 204.8 즉 204값과 205값 사이를 측정하게 됨

노이즈가 있어서 두 값이 모두 측정될 때 그 비율을 측정하면 204.8에 가까워짐

ADC 5V에서 12비트(4096)를 모사해서 1V를 측정할 때 예시는 원래의 샘플링 경과들의 평균 204.8에 2의 비트수차이 제곱 만큼 곱하면 819.2값을 획득할 수 있음

=====

SolarPowerManager를 진행중 모듈 오류 수정후 ADC와 USART 송신기능 구현 및 테스트 완료

Timer 기능 추상화하는데 비즈니스 로직에 어느정도로 설정을 노출할지 결정 -> HWRequest에 따라서 ChainDrive 구현체에 설정을 위임함

문제는 동적으로 Timer 설정을 바꾸지 못하게됨 나중에 get 기능과 set기능을 분리해서 개별적으로 ChainDrive 구현체가 설정할지 수정필요

그리고 타이머0~2번의 기능이 다르기 때문에 구현을 어떻게 해서 ChainDrive에 제공해줄지 좀더 공부해야함

=====

반드시 브래드보드로 프로토타입을 만들어서 테스트해볼것 그러면 pch 모스펫의 게이트 충전을 위한 전원 저항이 없어서 정상적인 동작을 하지 못하는것을 알 수 있음

그리고 아두이노 레귤레이터가 고장났는데 그 이유를 확인해본 결과 하드웨어 안전장치 없이 RAW핀에 12V이상의 전압이 들어가게 로직이 구성되어있었음

=====

마참내

벅컨버터의 스위칭을 위한 pch모스펫의 게이트전압이 제대로 충전/방전되지 않아서 특정 pwm에서만 모스펫이 켜지고 꺼졌던 문제를 해결함

인덕커와 캐패시터를 엄청추가해봤었지만 해결되지않았음

게이트 충전, 방전을 지연시켰던 저항을 많이 낮추니까 해결되고 의도했던대로 동작함

추가했던 캐패시터와 인덕터를 모두 제거하고 몇몇 코드 오류를 수정하면서 원래 회로대로 테스트해보니 잘 작동함

=====

브래드보드가 부족해서 만능기판에 회로대로 납땜을 하고 브래드보드에서 했던 테스트를 반복했지만 제대로 작동하지 않음

테스트, 수정중
