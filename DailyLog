2021-10-27 ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== =====

한달 반의 공백 끝에 다시 시작

원래 목적은 하드웨어자산(회로도 등)과 소프트웨어 자산(시스템과 어플리케이션 로직)을 분리해서 각각 관리하고 개발을 진행하고 테스트를 수행할 수 있는지 확인해보는 것임



배경

혼자서 만들수 있는 프로그램에는 투입될 수 있는 개발인력이 제한되기 때문에 전문성과 프로그램 크기와 시간에 제약이 있음

제약을 극복하기 위해서는 반드시 다른 개발자들과의 협업이 필요함 다른 개발자들과 협업하기위해서는 반드시 협업 기술과 조직화가 필요함



첫 직장에서 근무를 하면서 효율적인 협업은 생각처럼 이루어질수 없고 외부 요인이나 팀 내부요인으로 중요부분이 번복되거나 재개발 되는경우를 경험함

그리고 UI와 모듈개발자사이의 테스트 관점 차이처럼 개발부분별로 간단하게는 코딩스타일부터 개발철학에서 파생되는 소프트웨어의 품질 우선순위가 다르고

각각 타당한 이유가 있기 때문에 설득하기도 힘듬

예를 들어 모니터링 모듈을 만들때 멀티쓰레드 동기화 오류 최소화를 위해서 각 단계별 구분을 명확하게 나누고 각 단계를 추상화해서 확장성을 확보하는게 좋다고 생각해서 그렇게 설계했지만

이후 성능과 개발속도를 위해서 설계를 다르게 변경했는데 실제로 성능이 개선된거 같지도 않고 재설계시간과 동기화 오류 수정시간을 생각하면 그렇게 수정하는게 맞았나 의문이 듦

양쪽다 타당한 이유가 있었지만 비교할 수 있는 지표나 테스트 환경같은게 없어서 구체적으로 어떤게 어떤부분에 얼만큼 장점이 있고 단점이 어느정도인지 알수 없었음



프로그램이 복잡해지고 다양한 분야의 융합이 이루어지면서 각각의 기술적 깊이는 깊어짐 이때 다른 영역을 개발하려할 때 투입되는 개발자에게 필요로하는 역량이 커질것임

예를들면 클라이언트개발자-서버개발자 같이 비슷한 분야부터 데스크탑 어플리케이션 개발자-펌웨어 개발자 같은 기본 베이스가 달라서 처음부터 배워야하는 경우까지 다양함

개발조직에서는 어떤 단위에서든 각각의 전문 분야에 맞게 전문성을 활용하기위한 조직으로 나누어질 필요가 있고 만들고자하는 프로그램에서 담당하는 부분만 개발해야함



내용

3가지 배경에서의 문제를 해결하기위해서 프로그램 전체단위가 아니라 더 작은 단위로 개발프로세스가 진행되고 프로그램 전체에서는 각 결과물을 사용하는 형식으로 프로그램을 구성해서

프로그램 구성요소의 재사용성을 향상시키고 중복을 최소화하고 각 구성요소별 테스트 데이터나 테스트를 참고하고 한 개발프로세스 단위를 여러사람에게 할당하지 않게 해서

개발자가 자기의 역량을 완전히 발휘할 수 있는 환경을 구성하는것이 좋다고 생각함



결론

전혀 다른 분야와 협업하기 위해서는 전체 프로그램을 개발 분야별로 분할해서 설계하고 개발과정을 완전히 분리해야하고 그렇게 하기 위해서는 개발 과정에서 생성되는 결과물 역시 분리되어야함

요구사항을 전달하거나 전달 받거나 피드백을 받거나 의견을 교환하거나 여러 방식으로 협업을 할수있지만 서로 개발과정에 영향을 주지 않고 개발자가 적용 여부를 결정할 수 있어야함



2021-10-28 ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== =====

지금까지의 느낀점이나 경험 정리

진행 순서

프로젝트를 스캐치하고 프로토 타입 방식으로 기능을 하나씩 회로 시뮬레이트 사이트와 KiCad와 PlatformIO를 사용해서 하드웨어와 소프트웨어를 번가라가면서 개발 및 테스트

설계할 때 기능별 몇가지 후보를 설계하고 브래드보드에서 회로구성하고 프로그램 업로드 및 테스트, 어느정도 진행되면 만능기판에 납땜 후 테스트

진행 내용

입력 전압쪽부터 입력 전압의 역전극 보호회로, 역전극시 LED 작동 회로, 리니어 레귤레이터 회로, 리니어 레귤레이터의 입력전압을 차단하는 모스펫과

기본적으로 켜지고 MCU입력에 꺼지는 모스펫 게이트 회로, 벅 컨버터 회로, MCU Vraw 캐패시터 아날로그 입력 회로를 순서대로 설계 및 브래드보드에 테스트 후 만능기판에 납땜함

오류수정

N 모스펫을 사용하면 GND가 공통되지 않고 그러면 회로가 정상적으로 작동하지 않거나 아날로그 입력이 잘 안될수 있어서 입력 전압부분의 역전극 회로에만 N모스펫을 사용함

모스펫의 스위칭을 위한 BJT에 충분한 전류가 전달되지 않거나 모스펫 게이트의 충전과 방전 속도가 너무 느려서 제대로 스위칭 하지못한 오류 수정함

Vraw핀에 인가되는 전압이 리니어레귤레이터에서 스위칭 레귤레이터의 출력으로 전환될 때 소프트웨어적으로 스위칭 레귤레이터회로의 입력으로 전달되는 PWM이 스위칭 레귤레이터 출력이

12V이상으로 출력되지 않게 조절되었어야하지만 오류로인해서 일시적으로 12V이상이 인가되는경우가 있어서 아두이노의 레귤레이터가 고장남

아두이노의 온보드 레귤레이터를 입력전압이 35V까지 허용하는 L7805 리니어 레귤레이터로 치환함

느낀점

소프트웨어 개발과 하드웨어 개발은 개발과정이나 방법같은게 완전히 다르기 때문에 반드시 분리되어야함 특히 오류를 수정하는데 있어서 해당 분야에 맞는 지식이나 도구가 필요함

펌웨어 개발을 할때 하드웨어와 소프트웨어의 각각의 문제점에 대한 해결방법이 각각 양쪽에 존재할수있음

하드웨어 문제를 소프트웨어로 제어할 수 있고 소프트웨어의 문제를 하드웨어적으로 제어할 수 도있음

원래의 목적에 따라 소프트웨어의 자산과 하드웨어의 자산을 분리하면 레지스터같은 하드웨어에 의존하는 소프트웨어부분이 하드웨어 자산과 같이 가야하고

동시에 하드웨어 기능을 제공해주는 API나 구조체를 소프트웨어에 전달해주어야하기때문에 양쪽 모두 인터페이스에 의존하게됨

소프트웨어 자산 --> 인터페이스 <-- 하드웨어 자산 형식으로 소프트웨어는 인터페이스를 사용해야 하드웨어 자산이 변경될 때 기능을 유지할 수 있고 하드웨어는 약속된 인터페이스로 기능을 제공해야함

생각보다 하드웨어를 추상화하는데 추가되는 코드나 메모리가 많이 들어가서 제약이 큼

하지만 여전히 하드웨어에 따라서 소프트웨어를 재개발하는 비용보다 MCU를 더 상위라인으로 교체하거나 필요한 부분만 개발하면서 생기는 이점이 더 큰것같음

이 생각은 원래 소프트웨어 개발자라서 느끼는것일 수도 있지만 어찌됐든 엄격한 소프트웨어와 하드웨어 구분이 포팅과 같이 변경을 다른부분에 전달하지 않게 만들어서 변경부분을 제한하는데 유용함

학교 근로장학생일때 레거시 코드를 STM324xG 평가보드에 포팅 시도를 했을때 레거시 코드가 모두 한 폴더에 기능별 헤더와 C파일로 들어가 있어서 파악하는데 어려웠음 이때의 경험을 생각하면

변경부분을 제한하는 이점은 훨신 

