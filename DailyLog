2021-10-27 ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== =====

한달 반의 공백 끝에 다시 시작
원래 목적은 하드웨어자산(회로도 등)과 소프트웨어 자산(시스템과 어플리케이션 로직)을 분리해서 각각 관리하고 개발을 진행하고 테스트를 수행할 수 있는지 확인해보는 것임

배경
혼자서 만들수 있는 프로그램에는 투입될 수 있는 개발인력이 제한되기 때문에 전문성과 프로그램 크기와 시간에 제약이 있음
제약을 극복하기 위해서는 반드시 다른 개발자들과의 협업이 필요함 다른 개발자들과 협업하기위해서는 반드시 협업 기술과 조직화가 필요함

첫 직장에서 근무를 하면서 효율적인 협업은 생각처럼 이루어질수 없고 외부 요인이나 팀 내부요인으로 중요부분이 번복되거나 재개발 되는경우를 경험함
그리고 UI와 모듈개발자사이의 테스트 관점 차이처럼 개발부분별로 간단하게는 코딩스타일부터 개발철학에서 파생되는 소프트웨어의 품질 우선순위가 다르고
각각 타당한 이유가 있기 때문에 설득하기도 힘듬
예를 들어 모니터링 모듈을 만들때 멀티쓰레드 동기화 오류 최소화를 위해서 각 단계별 구분을 명확하게 나누고 각 단계를 추상화해서 확장성을 확보하는게 좋다고 생각해서 그렇게 설계했지만
이후 성능과 개발속도를 위해서 설계를 다르게 변경했는데 실제로 성능이 개선된거 같지도 않고 재설계시간과 동기화 오류 수정시간을 생각하면 그렇게 수정하는게 맞았나 의문이 듦
양쪽다 타당한 이유가 있었지만 비교할 수 있는 지표나 테스트 환경같은게 없어서 구체적으로 어떤게 어떤부분에 얼만큼 장점이 있고 단점이 어느정도인지 알수 없었음

프로그램이 복잡해지고 다양한 분야의 융합이 이루어지면서 각각의 기술적 깊이는 깊어짐 이때 다른 영역을 개발하려할 때 투입되는 개발자에게 필요로하는 역량이 커질것임
예를들면 클라이언트개발자-서버개발자 같이 비슷한 분야부터 데스크탑 어플리케이션 개발자-펌웨어 개발자 같은 기본 베이스가 달라서 처음부터 배워야하는 경우까지 다양함
개발조직에서는 어떤 단위에서든 각각의 전문 분야에 맞게 전문성을 활용하기위한 조직으로 나누어질 필요가 있고 만들고자하는 프로그램에서 담당하는 부분만 개발해야함

내용
3가지 배경에서의 문제를 해결하기위해서 프로그램 전체단위가 아니라 더 작은 단위로 개발프로세스가 진행되고 프로그램 전체에서는 각 결과물을 사용하는 형식으로 프로그램을 구성해서
프로그램 구성요소의 재사용성을 향상시키고 중복을 최소화하고 각 구성요소별 테스트 데이터나 테스트를 참고하고 한 개발프로세스 단위를 여러사람에게 할당하지 않게 해서
개발자가 자기의 역량을 완전히 발휘할 수 있는 환경을 구성하는것이 좋다고 생각함

결론
전혀 다른 분야와 협업하기 위해서는 전체 프로그램을 개발 분야별로 분할해서 설계하고 개발과정을 완전히 분리해야하고 그렇게 하기 위해서는 개발 과정에서 생성되는 결과물 역시 분리되어야함
요구사항을 전달하거나 전달 받거나 피드백을 받거나 의견을 교환하거나 여러 방식으로 협업을 할수있지만 서로 개발과정에 영향을 주지 않고 개발자가 적용 여부를 결정할 수 있어야함

2021-10-28 ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== =====

지금까지의 느낀점이나 경험 정리

진행 순서
프로젝트를 스캐치하고 프로토 타입 방식으로 기능을 하나씩 회로 시뮬레이트 사이트와 KiCad와 PlatformIO를 사용해서 하드웨어와 소프트웨어를 번가라가면서 개발 및 테스트
설계할 때 기능별 몇가지 후보를 설계하고 브래드보드에서 회로구성하고 프로그램 업로드 및 테스트, 어느정도 진행되면 만능기판에 납땜 후 테스트

진행 내용
입력 전압쪽부터 입력 전압의 역전극 보호회로, 역전극시 LED 작동 회로, 리니어 레귤레이터 회로, 리니어 레귤레이터의 입력전압을 차단하는 모스펫과
기본적으로 켜지고 MCU입력에 꺼지는 모스펫 게이트 회로, 벅 컨버터 회로, MCU Vraw 캐패시터 아날로그 입력 회로를 순서대로 설계 및 브래드보드에 테스트 후 만능기판에 납땜함

오류수정
N 모스펫을 사용하면 GND가 공통되지 않고 그러면 회로가 정상적으로 작동하지 않거나 아날로그 입력이 잘 안될수 있어서 입력 전압부분의 역전극 회로에만 N모스펫을 사용함
모스펫의 스위칭을 위한 BJT에 충분한 전류가 전달되지 않거나 모스펫 게이트의 충전과 방전 속도가 너무 느려서 제대로 스위칭 하지못한 오류 수정함
Vraw핀에 인가되는 전압이 리니어레귤레이터에서 스위칭 레귤레이터의 출력으로 전환될 때 소프트웨어적으로 스위칭 레귤레이터회로의 입력으로 전달되는 PWM이 스위칭 레귤레이터 출력이
12V이상으로 출력되지 않게 조절되었어야하지만 오류로인해서 일시적으로 12V이상이 인가되는경우가 있어서 아두이노의 레귤레이터가 고장남
아두이노의 온보드 레귤레이터를 입력전압이 35V까지 허용하는 L7805 리니어 레귤레이터로 치환함

느낀점
소프트웨어 개발과 하드웨어 개발은 개발과정이나 방법같은게 완전히 다르기 때문에 반드시 분리되어야함 특히 오류를 수정하는데 있어서 해당 분야에 맞는 지식이나 도구가 필요함
펌웨어 개발을 할때 하드웨어와 소프트웨어의 각각의 문제점에 대한 해결방법이 각각 양쪽에 존재할수있음
하드웨어 문제를 소프트웨어로 제어할 수 있고 소프트웨어의 문제를 하드웨어적으로 제어할 수 도있음
원래의 목적에 따라 소프트웨어의 자산과 하드웨어의 자산을 분리하면 레지스터같은 하드웨어에 의존하는 소프트웨어부분이 하드웨어 자산과 같이 가야하고
동시에 하드웨어 기능을 제공해주는 API나 구조체를 소프트웨어에 전달해주어야하기때문에 양쪽 모두 인터페이스에 의존하게됨
소프트웨어 자산 --> 인터페이스 <-- 하드웨어 자산 형식으로 소프트웨어는 인터페이스를 사용해야 하드웨어 자산이 변경될 때 기능을 유지할 수 있고 하드웨어는
약속된 인터페이스로 기능을 제공해야 이러한 형식의 이점을 얻을 수 있음
생각보다 하드웨어를 추상화하는데 추가되는 코드나 메모리가 많이 들어가서 제약이 큼
하지만 여전히 하드웨어에 따라서 소프트웨어를 재개발하는 비용보다 MCU를 더 상위라인으로 교체하거나 필요한 부분만 개발하면서 생기는 이점이 더 큰것같음
이 생각은 원래 소프트웨어 개발자라서 느끼는것일 수도 있지만 어찌됐든 엄격한 소프트웨어와 하드웨어 구분이 포팅과 같이 변경을 다른부분에 전달하지 않게 만들어서 변경부분을 제한하는데 유용함
학교 근로장학생일때 레거시 코드를 STM324xG 평가보드에 포팅 시도를 했을때 레거시 코드가 모두 한 폴더에 기능별 헤더와 C파일로 들어가 있어서 파악하는데 어려웠음 이때의 경험을 생각하면
변경부분을 제한하는 이점은 훨신 큼

2021-10-30 ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== =====

분해했던 회로 복구 로터리 인코더와 SDA, SCL핀에 점퍼케이블 연결, 점퍼케이블 부족으로 새로 주문

2021-10-31 ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== =====

SSD1306 드라이버를 사용한 128*32 OLED 회로 확인 및 데이터 시트 확인
신뢰할 수 없는 측정 도구와 불량에 대한 생각
3개의 1만원짜리 멀티미터가 있는데 3개중 1개가 제대로 작동하지 않음 원인을 몰라서 배터리도 갈아보고 분해해서 가변저항을 조절해봤지만 같은 증상
원인을 나중에 파악했는데 바나나클립과 연결된 멀티미터 테스터기가 불량이여서 제대로 작동하지 않은것임 다른것을 사용하니 다른 2개와 정상적으로 동작함
일반적인 제품은 QA과정으로 통해서 불량을 먼저 확인해서 일반적인 사용자가 제품의 기능들을 일일이 테스트하거나 스스로 사용할 때 기능이나 특성이 오차이내인지 확인하지 않지만
그러한 서비스가 약하거나 없는경우 받은 제품이 정상인지 확인해야할 수도 있음
IC를 주문한경우에도 특성이나 기능을 확인해야할지 모르겠음 여러 이유로 대체 부품을 사용하거나 새롭고 복잡한 MCU나 IC를 사용하려할때 테스트를 따로 해야하면 너무 힘들것같지만 필요함
대량생산에서는 모든 부품을 확인하고 제조하는것보다 마지막에 생산품의 기능을 확인하는것이 효율적이지만 집에서 만들때는 그렇게 할 수 없음 특히 지금처럼 측정장비가 불량인경우
대체할 스페어가 없다면 해결할 수 없음 좀 짜증나는 일이었지만 생각할 거리가 좀 있음

2021-11-01 ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== =====

Adafruit_SSD1306 코드 확인 내부적으로 아두이노 API를 사용하고있고 AVR/TWI 코드를 확인해보니 큰 기능없이 레지스트만 정의되어있고 로직핸들링기능이 없음
아두이노 없이 순수 AVR로 구현하고 싶은데 그러려면 AVR TWI 핸들링하는 라이브러리 구현 후 이것을 사용한 SSD1306 라이브러리를 구현해야함
그리고 해당 코드들을 어떻게 관리할지 좀더 알아봐야함 일단 아두이노 코드로 LCD와 회로가 이상없는것은 확인함

2021-11-03 ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== =====

CDL에서 atmega328p 레지스터를 직접 접근하고 있는데 이런 코드는 MCU를 변경하지 못하게 막는 요인임 원래 목표인 펌웨어에 유연성을 주기위해서는 이부분이 추상화되어야함
MCU별 코드가 아니라 회로별 코드가 되어야함 컴파일러가 변경되어도 C++로 작성된 부분은 재사용가능하게 할수 있음 그리고 HW구성을 변경하고 테스트할 때 APP를 변경해서 해당부분만 테스트할수있음
App은 CDL 인터페이스를 사용해서 필요한 기능을 구현하고 보드에서 독립적인 코드임
CDL 인터페이스는 APP에서 필요로하는 HW구성들(LCD, PWM 출력, IO, 인코더 등)의 인터페이스를 제공해줌, 이부분은 APP에도 의존하지 않아서 완전히 독립적인 모듈임
CDL 인터페이스를 구현한 보드 구현체는 SW적인 동작으로 HW요소들을 제어하기 위한 모듈, 여기서 HW회로에 의존성이 생김 HW개발하면서 같이 개발되어야함
CDL 구현체는 APP에서 필요로하는 HW구성의 구현들을 제공해줌, 여기서 어떤 구현들을 제공해줄지에 따라서 복잡한 HW특성을 숨김
HW구성의 구현체들을 결국 MCU레지스터 조작을 통해서 실제 HW회로의 기능을 사용함, 이 모듈이 다른 CDL 구현체에도 사용할 수 있게 만들어야함, 기존에는 atmega328p 레지스터를 직접 조작해서
유연성이 떨어지지만 MCU 레지스터를 한번더 추상화하면 다른 MCU에서도 사용할수 있게되고 그러면 다른 CDL 구현체에서도 사용할수 있음
CDL 구현체도 잘 나눠서 구분하고싶지만 TWI를 사용해서 SPI를 조작하고 그 SPI를 통해서 데이터 버스를 조작하고 그 데이터 버스로 HW회로로 구성된 기능을 사용하는 형식이나 실제 직면한 상황인
TWI를 사용해서 SSD1306 모듈을 조작해서 LCD를 사용하는 형식으로 HW회로에 따라서 너무 달라질 수 있음 그래서 CDL 구현체는 HW회로와 같은 생명주기를 가짐
MCU레지스터 인터페이스는 HW구성의 구현체들과 실제 MCU 레지스터를 분리해서 MCU가 변경되어도 HW구성 구현체들이 변경되지 않게 함
MCU레지스터 인터페이스를 만드는건 좀더 생각해봐야겠음 MCU에는 타이머나 TWI나 IO조작같은 여러 기능이 있는데 이것을 CDL 구현체에 둘지 HW구성 구현체에 둘지 아니면 MCU레지스터 인터페이스에
둘지 잘 모르겠음, MCU레지스터 인터페이스 대신 MCU 인터페이스로 만들어야할지도 모르겠음

2021-11-04 ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== =====

오늘 한것들
라이브러기 구조 스캐치 및 폴더 구조 스캐치, 컴파일이 막혀서 얼마 

오늘 알아낸것들
platformIO에서 로컬 라이브러리를 추가할 때 반드시 lib_deps를 사용해야함
lib_extra_dirs를 사용할 경우 나중에 PlatformIO Home에서 라이브러리로가서 해당 라이브러리를 삭제하면 실제 폴더의 파일들도 삭제됨
lib_deps를 사용해서 설정하면 PlatformIO프로젝트 내부에서 libdeps라는 폴더를 만들고 여기에 복사함 업데이트로 변경하지 않는경우 일일이 상태바의 다른 보드환경으로 변경하고 PlatformIO Home의
라이브러리로가서 해당 라이브러리를 삭제하고 다시 작업하던 보드환경으로 변경하면 자동으로 새로운 라이브러리가 설치됨
루트 헤더폴더에 서브 폴더를 만들고 그 안에 파일을 만드는 경우 구현파일(cpp)에서 포함하려할 때 폴어 이름까지 써주는게 나중에 의도하지 않은 포함을 제외할 수 있음
애초에 PlatformIO의 종속성관리자에서 그러한 기능이 없음, lib_deps로 추가한 경우 어떤 옵션을 주던 구현파일에서 폴더까지 쓰지 않은 포함들은 편집기에서는 이상이 없지만 PlatformIO에서 컴파일
할때 컴파일 에러가 발생함

2021-11-05 ~ 2021-11-10 ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== =====

ChainDrive를 재구현하면서 이전에 구현했던것보다 좀더 재사용성을 증가하고 유연성있게 만들기 위해서 프레임워크처럼 만들려고 하는데 순환참조 문제를 어떻게 해결해야할지 모르겠음
원하는것은 개발자가 SWC를 상속한 컴포넌트를 개발해서 실행하면 자동으로 로그를 출력하거나 모니터링데이터를 획득하게 만드는것인데 이때 다른 컴포넌트를 획득하게 하려면 SWC와 컴포넌트 획득
클래스사이에 순환참조관계가 형성됐음
컴포넌트 획득 클래스는 반환으로 SWC를 제공해야만하고 SWC는 컴포넌트 획득 클래스를 전달 받아야함
몇일을 고민하고 공부해본결과 2가지가 가능한것같음
1. SWC가 컴포넌트 획득 클래스를 전달받지 않고 전역으로 참고하거나 코드 구현에서만 참조함
2. 컴포넌트 획득 클래스가 SWC를 반환값으로 제공하지 않고 컴포넌트 클래스를 하나 더 만들어서 이것을 반환하고 실제 인스턴스는 SWC를 반환함

전역 인스턴스 접근은 제어할 수 없기 때문에 2안이 좋을것같지만 2안은 컴포넌트 클래스를 적절한 클래스로 전환하는 동작이 필요함
자바는 상호참조를 인터페이스와 그 인터페이스의 구현으로 의존성역전해서 상호참조를 해결하기 편했는데 C++은 좀 다른것같음
고민하다가 결국 2안으로 구현
왜냐하면 1안의 경우 나중에 확장하거나 HWComponent를 구현할때 계속해서 고려해야하고 무엇보다 개발자가 신경써야하는 제약이 추가됨 2안의 경우 변환하지 않으면 느려지지 않음 개발자가 개선할 수
있고 ChainDrive의 컨셉이 SW관리의 비용을 상위 MCU를 사용하는데 추가 비용으로 전환하는데 있기 때문에 2안이 더 좋다고 생각함

2021-11-11 ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== =====

구현한 코드들을 통합하는 과정에서 오류를 수정함
C++은 자바와다르게 헤더와 구현코드가 분리되어있는데 탬플릿기능을 사용하려고하면 에러가 발생함
c++의 다형성 특성중 하나인 탬플릿은 동적으로 뭔가 있는것이 아니라 탬플릿타입별로 다른 타입의 클래스가 탬플레이트되는것임 컴파일때 후 링크를 할때 구현 코드의 탬플릿 클래스의 생성과 같은
참조를 연결하게되는데 이때 탬플릿클래스 구현코드 하위에 필요한 템플릿형에대한 tamplate선언을 해주지 않으면 실제 코드가 생성되지 않고 그래서 다른 코드에서 필요한 탬플릿형에 접근하면
정의되지 않은 참조 에러가 발생함
또안 아두이노 프레임워크의 특성인지 avr 컴파일러의 특성인지 기본적으로 예외기능이 막혀있고 플래그를 변경해서 사용하려고해도 실제 필요한 표준 코드들이 없어서 에러가 발생함
또한 다운케스팅에 필요한 dynamic_cast역시 지원하지 않아서 별토의 타입검토기능이 필요함

2021-11-12 ~ 2021-11-14 ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== =====

SWC를 이벤트에 따라 가져와서 Action을 호출하는 코드 작성, 로거SWC 작성 진행중

2021-11-14 ~ 2021-11-15 ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== =====

계속해서 링커 에러가 발생했음
원인 찾고 수정

2021-11-16 ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== =====

논리적으로 총 3부분으로 나눔
시스템에 의존하는것들, 보드에 의존하는것들, 칩에 의존한는것들
칩에 의존하는것들은 MCU의 레지스터 접근이나 SSD1306같은 특정 칩이나 모듈의 코드
보드에 의존하는것들은 보드에 칩이 들어가있는것처럼 칩에 의존하는 코드를 호출함
시스템에 의존하는것들은 시스템을 구현하기위해서 사용되는 각 회로를 사용하는것처럼 보드에 의존하는것들을 호출함
칩에 의존하는것들은 AHW로 재구현 이전버전과 동일한 개념
보드에 의존하는것들은 이전버전에서는 SW코드로 올라가 있던 회로에 의존적인 부분을 분리한것
시스템에 의존하는것들은 시스템의 목적을 달성하기위한 프로그램
각각 칩이 변경되는경우, 보드의 구성이 변경되는경우 시스템이 변경되는 경우를 대응함
MCU를 atmega328p에서 stm32f103으로 변경하는경우 보드의 구성이 변경하기때문에 보드의 구성을 수정해서 MCU추상 클래스의 할당을 stm32f103사용 코드로 변경하면 끝
시스템이 변경되는경우 HW까지 영향을 주지 않는다면 다른부분은 건들필요 없이 해결가능, 영향을 준다면 해당 보드의 새로운 요구사항임

2021-11-16 ~ 2021-11-25 ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== =====

새 컴퓨터로 교체, 날아간 부분 재작성
template 개같네

2021-11-26 ~ 2021-11-27 ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== =====

문제가 되는 부분을 수정하고 아두이노 시리얼 통신 구현부분 테스트중

2021-11-28 ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== =====

usart 코드 동작 확인
현재 사용하는 이벤트 리스트를 설정하는 activedEventArrList 설정 오류 확인
ArrayList 초기값을 넣으면서 생성하는 생성자 추가
usartLoggerSWC 오류 수정 및 테스트

액션 이름이나 컴포넌트 이름의 크기를 저장해야 전부 출력가능함 sizeof는 string의 length를 대체할 수 없음
usart 입력기능 구현해서 디버깅 할지 입력받게 하면 

2021-11-29 ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== =====

컴포넌트와 액션의 이름을 그냥 문자열 대신 길이도 저장하는 시그니처클래스로 수정
로거 오류 수정 및 테스트
USART코드 다시 확인 및 HWComponent 설계
여러곳에서 Usart가 필요할때를 대비해서 HW자원을 관리할 컴포넌트 구현해야함

2021-11-30 ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== =====

usart 인터럽트 쓰기 오류 수정

2021-12-01 ~ 2021-12-04 ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== =====

여전한 인터럽트 문제 뭐가 문제인지 모르겠음
일단 ADC모듈 구현, ADC완료 인터럽트 사용부분 없어서 구현해야함

2021-12-05 ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== =====

여전히 USART 인터럽트가 제대로 안되는지 원인을 알 수 없음
ADC모듈 테스트, 이제 인터럽트 구현해야함
그리고 ADC의 내부 기준전압을 가지고 Vin전압을 알고싶은데 잘 안됨
계속해서 생각을 해봤지만 SWC 로거를 만들어두는게 맞은지 계속 고민하게됨 개발을하면서 생각보다 용략이 많이 들어가는거같음

2021-12-06 ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== =====

ADC 모듈 인터럽트 사용 코드 구현 및 테스트



